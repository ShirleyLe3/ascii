const base = "in vec2 aPosition;\nout vec2 vPosition;\nvoid main() {\nvPosition = .5 + .5*aPosition;\ngl_Position = vec4(aPosition, 0., 1.);\n}\n";
const pass1 = "#define MAP3(fn, v3) vec3(fn(v3.x), fn(v3.y), fn(v3.z))\n#define RGB(v1) mix(v1/12.92, pow((v1+.055)/1.055, 2.4), step(.04045, v1))\n#define LUM(v3) dot(MAP3(RGB, v3), vec3(.2126, .7152, .0722))\nprecision highp float;\nuniform sampler2D uSrc;\nuniform float uGamma;\nuniform float uSignal;\nuniform float uNoise;\nuniform float uRandom;\nin vec2 vPosition;\nout float vOutput;\nfloat hash13(vec3 p3) {\np3 = fract(p3 * 1031.);\np3 += dot(p3, p3.yzx + 19.19);\nreturn fract((p3.x + p3.y) * p3.z);\n}\nvoid main() {\nvec4 t = texture(uSrc, vPosition);\nfloat s = pow(LUM(t), uGamma);\nfloat n = hash13(vec3(vPosition, uRandom)) - 0.5;\nvOutput = uSignal*s + uNoise*n;\n}\n";
const pass2 = "#define U ${ width }\n#define V ${ height }\n#define X ${ width * height }\n#define Y ${ chars }\n#define Block float[X]\n#define CharCode int\nprecision highp float;\nuniform sampler2D uSrc;\nuniform sampler2D uLUT;\nuniform int uCharMap[Y];\nin vec2 vPosition;\nout int vOutput;\nBlock read() {\nvec2 center = vec2(textureSize(uSrc, 0))*vPosition;\nivec2 topLeft = ivec2(center) - ivec2(U, V)/2;\nBlock src;\nfor (int v = 0; v < V; v++)\nfor (int u = 0; u < U; u++)\nsrc[u + v*U] = texelFetch(uSrc, topLeft + ivec2(u, v), 0).r;\nreturn src;\n}\nCharCode closest(Block src) {\nstruct Pair { float diff; int idx; };\nPair closest = Pair(exp(1000.), 0);\nfor (int y = 0; y < Y; y++) {\nfloat diff = 0.;\nfor (int x = 0; x < X; x++)\ndiff += abs(src[x] - texelFetch(uLUT, ivec2(x, y), 0).r);\nif (diff < closest.diff)\nclosest = Pair(diff, y);\n}\nreturn uCharMap[closest.idx];\n}\nvoid main() {\nvOutput = closest(read());\n}\n";
export const vert = { base };
export const frag = { pass1, pass2 };
//# sourceMappingURL=shaders.js.map