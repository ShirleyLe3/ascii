const base = "in vec2 aPosition;out vec2 vPosition;void main(){vPosition=.5+.5*aPosition;gl_Position=vec4(aPosition,0.,1.);}";
const pass1 = "#define MAP3(fn,v3)vec3(fn(v3.x),fn(v3.y),fn(v3.z))\n#define RGB(v1)mix(v1/12.92,pow((v1+.055)/1.055,2.4),step(.04045,v1))\n#define LUM(v3)dot(MAP3(RGB,v3),vec3(.2126,.7152,.0722))\nprecision highp float;uniform sampler2D uSrc;uniform float uGamma;uniform float uSignal;uniform float uNoise;uniform float uRandom;in vec2 vPosition;out float vOutput;float hash13(vec3 p3){p3=fract(p3*1031.);p3+=dot(p3,p3.yzx+19.19);return fract((p3.x+p3.y)*p3.z);}void main(){vec4 t=texture(uSrc,vPosition);float s=pow(LUM(t),uGamma);float n=hash13(vec3(vPosition,uRandom))-0.5;vOutput=uSignal*s+uNoise*n;}";
const pass2 = "#define U ${width}\n#define V ${height}\n#define X ${width*height}\n#define Y ${chars}\n#define Inf exp(1000.)\n#define Block float[X]\n#define CharCode int\nprecision highp float;uniform sampler2D uSrc;uniform sampler2D uLUT;uniform int uCharMap[Y];in vec2 vPosition;out int vOutput;Block read(){vec2 center=vec2(textureSize(uSrc,0))*vPosition;ivec2 topLeft=ivec2(center+.25)-ivec2(U,V)/2;Block src;for(int v=0;v<V;v++)for(int u=0;u<U;u++)src[u+v*U]=texelFetch(uSrc,topLeft+ivec2(u,v),0).r;return src;}CharCode closest(Block src){struct Pair{float diff;int idx;};Pair closest=Pair(Inf,0);for(int y=0;y<Y;y++){float diff=0.;for(int x=0;x<X;x++)diff+=abs(src[x]-texelFetch(uLUT,ivec2(x,y),0).r);if(closest.diff>diff)closest=Pair(diff,y);}return uCharMap[closest.idx];}void main(){vOutput=closest(read());}";
export const vert = { base };
export const frag = { pass1, pass2 };
//# sourceMappingURL=shaders.js.map